* 抽象とは abstraction
    * 束縛とは?
    * 特定の問題を解決するツールあるいは仕掛け
    * 「鉛筆」も「筆記用具」も抽象
* 変数 variable
    * 識別子 identifier 綴りのこと
    * 格納域変数 store variable システムが計算に使用するもの。メモリの一部。
        * declare は 新しい格納域変数を生成する
    * 局所的変数(local variable)
* 関数
    * 関数抽象 functional abstraction
        * 抽象を構成するときに関数を使用すること
        * プログラムはタマネギ
* リスト
    * link の chain
    * 「cons する」(consing)
* プログラムの正しさ
    * 数学的モデル 言語の意味 semantics
    * 入力と出力の数学的定義 プログラムの仕様 specification
* 遅延計算
    * 必要とされるまで評価されない
* 高階プログラミング
* データフロー
    * まだ何も束縛されていない変数を使おうとするとどうなる？
    * 「待つ」のが美しい
    * 待てば操作を続行することができる → データフローという
    * データフローと concurrency がどのように協働するか
    * データフロー実行は常に同じ結果を与える
    * 性質
        * スレッドが別れていても計算は正しく行われる
        * 我慢強い。エラーを知らせないで、待つだけ。
    * スレッドと遅延を加えると、見かけが大きく変わることがある。
    * けど、操作や引数が変わらなければ、結果に変化はない。→ これがデータフローconcurrency の 重要な性質
* 明示的状態
    * メモリセル memory cell
        * variable と呼ばれるもの。前述のvariable とは違う。値の別名のこと
        * なんでも投げ込める箱
* オブジェクト
    * 内部メモリを持つ関数のことをこう呼ぶ。
    * インタフェース
        * オブジェクトがもつ操作のこと
    * カプセル化
    * インタフェースとその実装を分離することはデータ抽象の本質
    * インタフェースが同じでさえあれば、そのブログラムは正しく動く → 多様性( Polymorphism )
* クラス
    * 工場があるといい → class という
    * クラスとオブジェクトを用いてプログラミングすることを、オブジェクトベースプログラミングという
    * オブジェクトベースプログラミングに「継承」という考え方を加えると、オブジェクト指向プログラミングになる
* 非決定性と時間
    * 非決定性
        * 一定しないこと
        * 非決定性が生じるのは、基本操作が実行される正確な時刻を我々がしらないから
        * スレッドが独立なので、正確な時刻を知ることはできない
    * 観測可能な非決定性 observable nondeterminism → 競合条件 race condition と言われることがある
    * スレッドはインターリーブ interleave
        * 交代に少しづつ実行する
        * あらゆる交代の仕方を想定しないといけない
        * 歴史上の有名で危険なバグは、concurrency と明示的状態を一緒に扱うことの困難さを認識していなかったことに起因する
    * 明示的状態と並行性に関する教訓
        * 可能であっても一緒に扱うな！！！

