# 宣言的計算モデル

- 宣言的プログラミングモデル
  - 部分データ構造 partial data structure の上で関数を計算すること

### プログラミング

- 計算モデル
- プログラミング技法と設計原則の集合
- プログラムについて推論することを可能にする推論技法の集合

### 2.1 実用的プログラミング言語の定義

#### 2.1.1 言語の構文

- **文法**
  - 文法(grammer)は、単語(word) から文を作り上げる規則の集合
  - プログラミングにおいては、単語(word) == 字句(token)
  - 文 > 字句 > 文字
  - `文字の列 → 字句の列` tokenizer, lexical analyzer, 字句解析
  - `字句の列 → 構文木` parser 構文解析
- **Extended Backus-Naur Form**

  - **終端記号 (terminal symbol) と 非終端記号 (nonterminal symbol)**
    - https://ja.wikipedia.org/wiki/%E7%B5%82%E7%AB%AF%E8%A8%98%E5%8F%B7%E3%81%A8%E9%9D%9E%E7%B5%82%E7%AB%AF%E8%A8%98%E5%8F%B7
    - 終端記号 == 字句
      - 生成規則によって、それ以上は変換されない記号
      - 右辺の記号列中のみにあらわれる
    - 非終端記号 == 字句の列
      - 規則の左辺に現れる
      - 他の記号列と置換できるものとして定義されている記号
      - 置換されうる記号
      - ある種の変数名のようなもの

- **文脈自由文法(context-free grammer) と 文脈依存文法(context-sensitive grammer)**

  - 文脈自由文法
    - 形式言語の理論のなにからしい
    - https://ja.wikipedia.org/wiki/%E6%96%87%E8%84%88%E8%87%AA%E7%94%B1%E6%96%87%E6%B3%95
    - \<digit\>のような非終端記号(他の記号と置換できる)がどこで使われようと、その展開が常に同じであるから。文脈に依存しない。
  - 文脈依存文法
    - 変数を使う非終端記号は、すでに宣言された変数しか使うことができない。 → 文脈に依存
  - プログラミング言語の構文
    - 文脈自由文法 + 追加条件の集合 => 文脈依存文法

- **あいまい性**
  - 優先順位(precedence) と 結合性(associativity) の２つの条件を加えることで解決できる

#### 2.1.2 言語の意味

- **核言語手法**

  1. 核言語という単純な言語を定義すること
  2. 各言語へ翻訳する仕方を定義すること
     - 翻訳の仕方
       - [言語抽象](#言語抽象)(lingistic abstraction)
       - [糖衣構文](#糖衣構文)(syntactic sugar)

- **形式的意味**

  - 操作的意味 operational semantics
    - ある文が抽象的マシンにおいてどのように実行されるかを示す。この本では、これ。
  - 公理的意味
  - 表示的意味
  - 論理的意味

- <a name="言語抽象"></a> **言語抽象**

  - 新しい要素は抽象でもあり、言語の構文への追加でもある(?) → 言語抽象という。
  - 言語抽象の定義の段階
    1. 新しい文法要素を定義すること
    2. それの核言語への翻訳を定義すること
  - 手続き
  - すべての引数が明示的で、複数の出力があり得る

- <a name="糖衣構文"></a> **糖衣構文**

  - 略記法

- **言語設計**
  - 3 つの段階
    - 最初に定義されるとき、言語的支援はなにもない
    - それが有益だと考えられると、それに言語的支援を与えることが決断される → 言語抽象となる
    - 言語の一部となる

### 2.2 単一代入格納域 single-assignment store

はじめ束縛されていないで、後に１つの値としか束縛できない変数の集合

#### 2.2.1 宣言的変数 declarative variable

- 単一代入格納域の中の変数は宣言的変数と呼ばれる
- データフロー変数 (dataflow variable) とも呼ばれる
- 一旦束縛されると束縛されたままで、その値との区別がつかなくなる
- つまり、計算の中であたかも値であるかのようにつかえるということ

#### 2.2.2 値格納域 value store

- すべての変数が値に束縛されている格納域のこと
- 恒久的写像 `変数 → 値`
- なぜ単一代入格納域を導入したのか
  - 他の言語は値格納域またはセル格納域を使っているのに([2](#q2))
  1. **部分値 (partial value)**([3](#q3))([5](#q5))について計算したいこと
  2. 宣言的並行性
  3. 関係プログラミングと制約プログラミング

#### 2.2.3 値生成

- x_i = value
  - 格納域中に value を構築し、その値を変数 x_i に束縛する
  - その変数がすでに束縛されていば、2 つの値が両立する(compatible)かどうか調べられる([4](#q4))

#### 2.2.4 変数識別子

- 変数と値は**格納域実体(store entity)**
- 格納域のそとから格納域実体を参照できるとうれしい → それが変数識別子(variable identifier)の役割
- 変数識別子は**字面**
- 格納域の外から 1 つの格納域実体を参照するもの
- 変数識別子から格納域実体への写像を**環境 environment** という
- ex) 任意の識別子が格納域の変数*x_i*を参照するとき、環境{\<x\> → _x_i_} (\<x\>は任意の識別子)

#### 2.2.5 識別子を使う値生成

- 変数がいったん束縛されると値と見分けがつかない
- `=`は束縛操作を表す

#### 2.2.6 部分値 partial value (<a name="q5">q5</a>)

- 束縛されていない変数を含んでいるかもしれないデータ構造([6](#q6)) == `部分値(partial value)`
- 束縛されていない変数のない部分値 → **完全値(complete value)**
- 宣言された変数にいくつかの部分値を束縛することができる。ただし、それらの部分値は両立([4](#q4))するものでないと行けない
- 両立するとは
  - 束縛されていない変数があっても、すべての部分値が等しくなる可能性がある場合
  - ex) `person(age:25)` と `person(age:x)` は両立する

#### 2.2.7 変数の、変数への束縛

- 変数に変数を束縛することができる

#### 2.2.8 データフロー変数

- 宣言的モデルでは、変数の生成とその束縛は、別々に行われる
-

## 疑問

### 1.「部分データ構造 partial data structure の上で関数を計算すること」

- どういう意味？
- 部分データ構造とは

### <a name="q2"></a>2.単一代入格納域と値格納域

- たぶん自分の中でこの２つの区別がちゃんとついていない
- 束縛されていないかどうかの違い？
- だったら、他の言語では、値格納域を使っているってどういうこと？そういう言語って具体的になに？
- セル格納域を使うというのは理解出来る。自分たちがよく知っている言語のこと。
- よくわからんけど次の章でわかるっぽい

### <a name="q3"></a>3.部分値 partial value

- 部分値(partial value)とは

### <a name="q4"></a>4.両立

- 両立とは

### <a name="q6"></a>6.部分データ構造

- `束縛されていない変数を含んでいるかもしれないデータ構造`は、([1](#q1))の`部分データ構造`と同じ？違う？
