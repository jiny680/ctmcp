# 宣言的計算モデル

- 宣言的プログラミングモデル
  - 部分データ構造 partial data structure の上で関数を計算すること

## プログラミング

- 計算モデル
- プログラミング技法と設計原則の集合
- プログラムについて推論することを可能にする推論技法の集合

## 2.1 実用的プログラミング言語の定義

### 2.1.1 言語の構文

- **文法**
  - 文法(grammer)は、単語(word) から文を作り上げる規則の集合
  - プログラミングにおいては、単語(word) == 字句(token)
  - 文 > 字句 > 文字
  - `文字の列 → 字句の列` tokenizer, lexical analyzer, 字句解析
  - `字句の列 → 構文木` parser 構文解析
- **Extended Backus-Naur Form**

  - **終端記号 (terminal symbol) と 非終端記号 (nonterminal symbol)**

    - https://ja.wikipedia.org/wiki/%E7%B5%82%E7%AB%AF%E8%A8%98%E5%8F%B7%E3%81%A8%E9%9D%9E%E7%B5%82%E7%AB%AF%E8%A8%98%E5%8F%B7
    - 終端記号 == 字句

      - 生成規則によって、それ以上は変換されない記号
      - 右辺の記号列中のみにあらわれる

    - 非終端記号 == 字句の列
      - 規則の左辺に現れる
      - 他の記号列と置換できるものとして定義されている記号
      - 置換されうる記号
      - ある種の変数名のようなもの

- **文脈自由文法(context-free grammer) と 文脈依存文法(context-sensitive grammer)**

  - 文脈自由文法
    - 形式言語の理論のなにからしい
    - https://ja.wikipedia.org/wiki/%E6%96%87%E8%84%88%E8%87%AA%E7%94%B1%E6%96%87%E6%B3%95
    - \<digit\>のような非終端記号(他の記号と置換できる)がどこで使われようと、その展開が常に同じであるから。文脈に依存しない。
  - 文脈依存文法
    - 変数を使う非終端記号は、すでに宣言された変数しか使うことができない。 → 文脈に依存
  - プログラミング言語の構文
    - 文脈自由文法 + 追加条件の集合 => 文脈依存文法

- **あいまい性**
  - 優先順位(precedence) と 結合性(associativity) の２つの条件を加えることで解決できる

### 2.1.2 言語の意味

- **核言語手法**

  1. 核言語という単純な言語を定義すること
  2. 各言語へ翻訳する仕方を定義すること
     - 翻訳の仕方
       - [言語抽象](#言語抽象)(lingistic abstraction)
       - [糖衣構文](#糖衣構文)(syntactic sugar)

- **形式的意味**

  - 操作的意味 operational semantics

    - ある文が抽象的マシンにおいてどのように実行されるかを示す。この本では、これ。

  - 公理的意味
  - 表示的意味
  - 論理的意味

- <a name="言語抽象"></a> **言語抽象**

  - 新しい要素は抽象でもあり、言語の構文への追加でもある(?) → 言語抽象という。
  - 言語抽象の定義の段階
    1. 新しい文法要素を定義すること
    2. それの核言語への翻訳を定義すること
  - 手続き
  - すべての引数が明示的で、複数の出力があり得る

- <a name="糖衣構文"></a> **糖衣構文**

  - 略記法

- **言語設計**
  - 3 つの段階
    - 最初に定義されるとき、言語的支援はなにもない
    - それが有益だと考えられると、それに言語的支援を与えることが決断される → 言語抽象となる
    - 言語の一部となる

## 2.2 単一代入格納域 single-assignment store

はじめ束縛されていないで、後に１つの値としか束縛できない変数の集合

### 2.2.1 宣言的変数 declarative variable

- 単一代入格納域の中の変数は宣言的変数と呼ばれる
- データフロー変数 (dataflow variable) とも呼ばれる
- 一旦束縛されると束縛されたままで、その値との区別がつかなくなる
- つまり、計算の中であたかも値であるかのようにつかえるということ

### 2.2.2 値格納域 value store

- すべての変数が値に束縛されている格納域のこと
- 恒久的写像 `変数 → 値`
- なぜ単一代入格納域を導入したのか

  - 他の言語は値格納域またはセル格納域を使っているのに([2](#q2))

  1. **部分値 (partial value)**([3](#q3))([5](#q5))について計算したいこと
  2. 宣言的並行性
  3. 関係プログラミングと制約プログラミング

### 2.2.3 値生成

- x_i = value
  - 格納域中に value を構築し、その値を変数 x_i に束縛する
  - その変数がすでに束縛されていば、2 つの値が両立する(compatible)かどうか調べられる([4](#q4))

### 2.2.4 変数識別子

- 変数と値は**格納域実体(store entity)**
- 格納域のそとから格納域実体を参照できるとうれしい → それが変数識別子(variable identifier)の役割
- 変数識別子は**字面**
- 格納域の外から 1 つの格納域実体を参照するもの
- 変数識別子から格納域実体への写像を**環境 environment** という
- ex) 任意の識別子が格納域の変数*x_i*を参照するとき、環境{\<x\> → _x_i_} (\<x\>は任意の識別子)

### 2.2.5 識別子を使う値生成

- 変数がいったん束縛されると値と見分けがつかない
- `=`は束縛操作を表す

### 2.2.6 部分値 partial value (<a name="q5">q5</a>)

- 束縛されていない変数を含んでいるかもしれないデータ構造([6](#q6)) == `部分値(partial value)`
- 束縛されていない変数のない部分値 → **完全値(complete value)**
- 宣言された変数にいくつかの部分値を束縛することができる。ただし、それらの部分値は両立([4](#q4))するものでないと行けない
- 両立するとは
  - 束縛されていない変数があっても、すべての部分値が等しくなる可能性がある場合
  - ex) `person(age:25)` と `person(age:x)` は両立する

### 2.2.7 変数の、変数への束縛

- 変数に変数を束縛することができる

### 2.2.8 データフロー変数

- 宣言的モデルでは、変数の生成とその束縛は、別々に行われる
- 同じタイミングに束縛されるものもある。関数型言語とか。

## 2.3 核言語

### 2.3.1 構文

- **文の構文**
- **値の構文**

  - レコードとパターンにおいて、その引数 x_1 … x_n はすべてことなるものでなければならない
  - それにより、すべての「変数の、変数への束縛」が明示的な核言語操作としてかけることが保証される([7](#q7))

### 2.3.2 値と型

- **ADT(abstract data type)**
- **基本型**
- **動的型付け**
- **型の階層**

### 2.3.3 基本型

- 数
- アトム
- ブール型
- レコード
  - アトムはフィールドのないレコード
- タプル
  - タプルはレコード。フィールド名が 1 から始まる連続した整数
- リスト
- 文字列
- 手続き

### 2.3.4 レコードと手続き

- なぜレコードと手続きが基本概念になっているのか

- **レコードの威力**

  - その他の技法の有効性が高まるらしい

- **なぜ手続きか?**

  - 簡単
  - 入力と出力の個数について何ら仮定を置かないので柔軟性がある

### 2.3.5 基本操作

## 2.4 核言語の意味

### 2.4.1 基本概念

- **変数識別子と静的スコープ**

  - **スコープ(scope)**: ある識別子がある特定の変数を参照するプログラム領域。スコープの外では、**その識別子は同じことを意味しない**。識別子がその意味を保つプログラムの領域。
  - 静的スコープは局所的。ある一部分を見るだけで、識別子の意味が決められる。

- **手続き**

  - **参照呼び出し(call by reference)**

- **外部参照のある手続き**

  - **自由識別子(free identifier)**
    - 定義されていない識別子
  - 自由識別子の一部しか引数にしていない手続きを定義すると？
    - 手続きが定義されたときの識別子が使われる。静的スコープをもつから。

- **動的スコープ vs 静的スコープ**
- **手続き抽象**

  - 手続き抽象: 文が手続きに抽象化された
  - 自由識別子
  - 静的スコープ
  - この本に出てくる最も強力なツールの 1 つが**手続き抽象**と**静的スコープ**を併せたもの

- **データフロー的振る舞い**

  - 第 2 の強力なツールである、**並行性**の根底となるもの
  - 簡単に実装できるみたい。あとでわかるみたい。

### 2.4.2 抽象マシン

- 核言語の意味は、操作的意味によって定義される。
- 定義
  - **単一代入格納域 σ**
    - 格納域変数の集合。束縛されていない変数の集合と、数・レコード・手続きなどに束縛された変数の集合という二組に分かれる。
    - 値に束縛されている格納域変数はその値と区別できないので、格納域変数は**格納域実体(store entity)**と言われることがある。
  - **環境 E**
    - **変数識別子から σ の中の実体への写像**。[X → _x_, Y → _y_]みたいな対の集合として表現される。
  - **意味言明**
    - 対`(<s>, E)`。`<s>`は文。`E`は環境。
  - **実行状態**
    - 対`(ST, σ)`。`ST`は意味言明のスタック(stack の ST?)。`σ`は**単一代入格納域**
  - **計算**
    - 実行状態の初期状態から始まる、実行状態の列。
- **計算ステップ(computation step)**
  - 計算ステップは原始的。all at once
- **環境に従う計算**
  - 添加(adjunction)
    - 既存の環境に 1 つの写像を加えて新しい環境を定義すること。
  - 限定(restriction)
    - ある環境の部分集合となるような新しい環境を定義すること。

### 2.4.3 待機不能な文

- 識別子の自由出現と束縛出現

  - 出現
  - 字句的スコープ
  - 自由な識別子出現は、不完全なプログラム片の中にしか存在しない
  - 束縛された識別子出現と束縛された変数
    - 束縛された識別子出現は**lexical**。そして、変数はただの文字の連なり。実行時には存在しない。
    - 束縛された変数は実行時に存在する。

- **手続き値（閉包）**
  - 自由識別子 by p.59
  - 「自由識別子は仮引数のこともあり」????
    - 仮引数って時点で定義されてるんじゃないの？自由識別子は定義されていない識別子のことなはず。
  - p.67 上部の言っていることがちゃんと理解できていない気がする...????

### 2.4.3 待機可能な文(suspendable statement)

- **活性化条件(activation condition)**を持つ
- 宣言的モデルにおいては、文が一旦待機状態に入ると決して再開しない
  - 活性化条件を真にするような別の実行がないから
- arity: 引数の個数

### 2.4.5 基本概念再訪

- 変数識別子と静的スコープ
  - なぜここで、{ _y_=1, _x_=_y_ } みたいなことをしている????
- 手続き定義と宣言
  - なんで Proc の CE は ずっと Φ???? 外部参照がないから? → 多分そう。Proc の仮引数に必要なものが揃っているので、Proc 自身は環境をもっていない。
- 外部参照のある手続き(1)
- 外部参照のある手続き(2)

## 2.5 メモリ管理

### 2.5.1 末尾呼び出し最適化

- 末尾呼び出し最適化(last call optimization, tail call optimization)
  - k 番目の再帰呼び出しの際のスタックの形は常に[({Loop10 I+1}, {I→i_(k-1)})]となる
  - つまりただ 1 つの意味言明と一定の大きさのその環境があるだけ。
  - 意味スタックと格納域の大きくなり方は異なる
    - 意味スタックは一定の大きさに限られるけど、格納域は呼び出しのたびに大きくなる
    - なぜ、この大きくなり方が問題にならないのか
      - 本当に必要なのは、1 つの変数だけ。それ以外は格納域にある必要はない。
      - 「この例の場合、変数を格納域でなくスタックに格納すれば問題は解決できる」なんで????
      - 「スタックに用意に格納できないようなデータを大量に持っている」どんな????
      - なので、不要な変数を削除するという問題は解決しないといけないらしい

### 2.5.2 メモリライフサイクル(memory life cycle)

### 2.5.3 ガーベッジコレクション(garbage collection)

### 2.5.4 ガーベッジコレクションは黒魔術ではない

- メモリリークを避けること
  - 必要がなくなったデータ構造を参照しないようにしなければならない
  - 「宣言的モデルでこの掃除をできないことはないが厄介である」????
- 外部資源(external resource)の管理
  - 外部データ構造が外部資源を参照する場合
    - レコードはグラフィックディスプレイのグラフィカルな実体やファイルシステムのオープンされたファイルに対応できる
    - レコードが必要なくなったら、実体は削除されるべきだし、ファイルはクローズされるべき。
      - そうでないとリークしてしまう。
      - このために、データ構造が到達不可能になったときに採るアクションを定義する**最終化(finalization)**という技法を用いる → 6.9.2 で
  - 外部資源が Mozart データ構造を必要とする場合????
    - 明快に処理できる場合が多い
    - 一般的な解は、外部資源を表すために Mozart プログラムの一部を別扱いすること。
    - たまたま捨てられることがないように、アクティブでなければならない。== それ自身のスレッドを持っていないと行けない。
    - 外部資源の Proxy とみなせるもの。
    - この Proxy は外部資源が必要とする限り、Mozart データ構造への参照を維持し、外部資源はそのデータ構造が不要になったら、Proxy に通知する。

### 2.5.5 Mozart のガーベッジコレクタ

- 自動メモリ管理を行う
  - ローカルガーベッジコレクタ → 双空間複写アルゴリズム(copying dual-space algorithm)を使う
  - 分散ガーベッジコレクタ → 分散プログラミングのために使われる
- ここは難しくてよくわからん

## 2.6 核言語から実用言語へ

### 2.6.1 構文上の便宜

- 式
  - 操作の列に対する糖衣構文
  - 文も操作の列だけど値は返さない
- andthen
  - js での &&
- orelse
  - js での ||
- 入れ子マーカー

```oz
local X in
  {Obj get(x)}
  {Browse X}
end
% 上のとこれが同じらしい
{Browse {Obj get($)}}
```

### 2.6.2 関数(fun 文)

### 2.6.3 対話的インタフェース(declare 文)

- 「前の declare と違うのは、<stmt>が(declare を含んでいなければ)大域的変数を宣言しないことである」????

## 2.7 例外

### 2.7.1 動機と基本概念

- エラーとは「プログラムが意図する振る舞いと実際の振る舞いとの差である」
- エラー局限原則
  - 波及を防いでプログラム全体を汚染しないようにしなければならない
  - 例外処理機構により、「コンポーネント」の内部からその境界へ「ジャンプ」が引き起こされる
- ジャンプは単一操作であるべきである

### 2.7.2 例外を持つ宣言的モデル

- catch 文は意味スタック上の「マーカー」????
- catch
  - 「catch 文は skip 文同様、何もしない」????

## 2.8 進んだ話題

### 2.8.1 関数型プログラミング

- 関数型プログラミングとは、**完全値についての数学的な関数を定義すること**
- **λ 計算**
  - 共通操作
    - 関数を定義することと、関数を計算すること
- 宣言的モデルを制限すること
  - ２つの点で λ 計算より一般的
    - 部分値の上で関数を定義すること
    - 手続き的構文を使用すること
  - 関数型言語の制限は
    - 変数を宣言するとき、直ちに値に束縛する。
    - 手続きでなく関数だけを使う。

### 2.8.2 単一化と内包(entailment)

- 単一化(unification)
  - 変数に値を束縛することは、単一化と言われる操作の特殊な場合。
  - 単一化を概念化するいい方法は、単一代入格納域に情報を追加する操作と考えること

## 疑問

### 1.「部分データ構造 partial data structure の上で関数を計算すること」

- どういう意味？

### <a name="q2"></a>2.単一代入格納域と値格納域

- たぶん自分の中でこの２つの区別がちゃんとついていない
- 束縛されていないかどうかの違い？
- だったら、他の言語では、値格納域を使っているってどういうこと？そういう言語って具体的になに？
- セル格納域を使うというのは理解出来る。自分たちがよく知っている言語のこと。
- よくわからんけど次の章でわかるっぽい

### <a name="q3"></a>3.部分値 partial value

- 部分値(partial value)とは

### <a name="q4"></a>4.両立

- 両立とは

### <a name="q6"></a>6.部分データ構造

- `束縛されていない変数を含んでいるかもしれないデータ構造`は、([1](#q1))の`部分データ構造`と同じ？違う？

### <a name="q7"></a>7.値の構文

- 意味がわからん
