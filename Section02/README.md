- 計算モデル　 computation model
  - 抽象マシン
- プログラミングモデル
- 推論技法
- 宣言的プログラミングモデル
  - 最も簡単な計算モデル
  - 部分データ構造 partial data structure の上で関数を計算すること (?)
  - 状態なしプログラミング stateless programming
- 構文 sytax と意味 semantics
  - 構文
  - 文脈自由文法によって定義
  - 意味
  - 1. 実用的言語 → 核言語に翻訳
  - 2. 核言語の意味を与える
- 言語の構文
  - tokenizeer, lexical analyzer, 字句解析 文字の列 → 字句の列
  - parser 構文解析 字句の列 → 構文木
  - バッカス・ナウア記法 EBNF Extended Backus-Naur Form
  - 終端記号 terminal symbol
    - 字句
  - 非終端記号 nonterminal symbol
    - 字句の列
  - 文脈自由文法 context-free grammer
  - <digit>のような非終端記号はどこで使われようと、その展開が常に同じ
  - 文脈依存文法 context-sensitive grammer
  - 変数は使用する前に宣言しないといけない
  - 文脈自由文法では表現できない。
  - 変数を使う非終端記号は、すでに宣言された変数しか使用することができない → 文脈に依存している
  - プログラミング言語の構文は、2 つに分けて定義
  - 文脈自由文法
  - それを補う、その言語が課すべつの条件の集合
    - ex: 使用前に宣言など
  - あいまい性
  - 優先順位
  - 結合性
- 言語の意味

  - プログラムについて、複雑にすることなく、推論したい
  - 核言語という手法
  - プログラミング言語の意味を定義するのに核言語手法を採用している
  - 言語のすべての構成要素が各言語への翻訳という形で定義
  - 核言語手法
  - 核言語という非常に単純な言語を定義すること
  - 核言語へ翻訳する仕方を定義すること
    - 翻訳の方法は２種類
    - 言語抽象 linguistic abstraction と 糖衣構文 syntax suger
  - 形式的意味
  - 操作的意味 operational semantics \*
  - 公理的意味 axiomatic semantics
  - 表示的意味 denotational semantics
  - 論理的意味 logical semantics
  - 言語抽象
  - 新しい要素を追加したくなる。
  - 新しい要素は、抽象でもあり、言語の構文への追加でもある → 言語抽象 linguistic abstraction という
  - 段階
    - 新しい文法要素を定義すること
    - それの各言語への翻訳を定義すること
  - 手続きとは
  - 糖衣構文
  - 言語設計
  - 3 つの段階
    - 最初に定義されるとき、言語的支援はなにもない
    - それが有益だと考えられると、それに言語的支援を与えることが決断される → 言語抽象となる
    - 言語の一部となる

- 単一代入格納域( single-assignment store )

  - 単一代入格納域: はじめに束縛されていないだけで、後に 1 つの値としか束縛できない変数の集合
  - 宣言的変数( declarative variable ) == データフロー変数( dataflow variable:
  - 単一代入格納域の中の変数
  - 一旦束縛されると以後束縛されたまま
  - 値と変数の区別がつかなくなる
  - 計算の中であたかも値のように使える
  - 値格納域( value store )
  - すべての変数が値に束縛されている格納域のこと
  - 値格納域は、変数から値への恒久的写像
  - 関数型言語は、関数のことも値として扱うので、値格納域で ok
  - なぜ、単一代入格納域
    - 部分値 partial value? について計算したい
    - 宣言的並列性、関係プログラミング、制約プログラミングで必要
  - 値生成
    - x_i = value
    - 格納域中に value を 構築し、その値を変数 x_i に束縛する
  - 変数識別子 variable identifier
    - 変数と値は格納域自体 store identity ?
    - 格納域の外から格納域実体が参照できたら嬉しい。たしかに
    - それが変数識別子 variable identifier
    - 変数識別子はただの字面である。
    - 格納域の外から 1 つの格納域実体を参照するもの
    - 変数識別子から格納域実体への写像を環境 environment という
    - ソースコードに出てくる中の変数名は、変数でなく、変数識別子
  - 識別子を使う値生成
  - 部分値
    - 束縛されていない変数を含んでいるかもしれないデータ構造
    - それがなくなったのが完全値
  - 変数の、変数への束縛
  - データフロー変数
    - ある変数が束縛されるまでプログラムを待たせるような宣言的変数をデータフロー変数という
    - 宣言的モデルはデータフロー変数を使用する。並列プログラミングに有効だから。

- 核言語

- p51 レコードとパターンにおいて、その引数 x_1 … x_n はすべてことなるものでなければならない?????????
- それにより、すべての「変数の、変数への束縛」が明示的な核言語操作としてかけることが保証される??????????
- 値と型
- 基本型
  - 数、レコード、手続き(procedure)
- 動的型付け
  - 静的型付け: すべての変数の型は、コンパイル時にわかる
  - 動的型付け: 変数が束縛されるときに初めてわかる
  - 宣言的モデルは動的型付け
- 型の階層
- 基本型
- 数
- アトム
- ブール型
- レコード
  - アトムはフィールドのないレコード
- タプル
  - タプルはレコード。フィールド名が 1 から始まる連続した整数
- リスト
- 文字列
- 手続き

- レコードと手続き
- なぜレコードと鉄続きを基本概念にしたのか
  - 手続きは、入力と出力の個数について何ら仮定を置かないので、柔軟性がある
- 核言語の意味
- 核言語の実行は、部分値の上で関数を計算すること???
- 変数識別子と静的スコープ
  - 静的スコープ(lexical scope) vs 動的スコープ(dynamic scope)
- 手続き
  - 参照呼び出し(call by reference)
  - 自由識別子 (free identifier): 定義されていない識別子
  - 静的スコープが正しい
    - ある手続きが定義されたときに稼働中の手続きは、それが呼ばれたときの環境に無関係に稼働を続ける。これは重要なソフトウェアエンジニアリング的性質である。
    - 動的スコープが有用な場面もある。ネットワークごしの手続きの実行など。
  - 手続き抽象 procedural abstraction
    - 手続き抽象
    - 自由識別子
    - 静的スコープ
- 抽象マシン
  - 核言語の意味を操作的意味論によって定義
    - 環境 environment
    - 意味言明 semantic statement
    - 意味スタック semantic stack
    - 実行状態 execution state
    - 計算 computation
  - 環境に関する操作
    - 添加 adjunction
    - 限定 restriction
